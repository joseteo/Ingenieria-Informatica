-- Descripción de una bola cuadrada que se mueve hacia arriba y hacia abajo,
-- respetando los márgenes superior e inferior de la pantalla.
--
-- Basado en ejemplo de Hamblen, J.O., Hall T.S., Furman, M.D.:
-- Rapid Prototyping of Digital Systems : SOPC Edition, Springer 2008.
-- (Capítulo 10)
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
LIBRARY lpm;
USE lpm.lpm_components.ALL;

ENTITY game_controller IS
	GENERIC(
			Pala1_Init_X : Natural := 320;
			Pala2_Init_X : Natural := 10
	);
    PORT (
			Red, Green, Blue : OUT STD_LOGIC;
			vs : IN STD_LOGIC;
			pixel_Y, pixel_X : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
			BT1_UP, BT1_DOWN : IN STD_LOGIC;
			BT2_UP, BT2_DOWN : IN STD_LOGIC
    );
END game_controller;

ARCHITECTURE funcional OF game_controller IS
	 -- Bola
    SIGNAL Bola_on : STD_LOGIC;
    SIGNAL Bola_Desplaza_Y : STD_LOGIC_VECTOR(9 DOWNTO 0);
	 SIGNAL Bola_Desplaza_X : STD_LOGIC_VECTOR(9 DOWNTO 0); -- 2.3
    SIGNAL Bola_Y : STD_LOGIC_VECTOR(9 DOWNTO 0);
	 SIGNAL Bola_X : STD_LOGIC_VECTOR(9 DOWNTO 0); -- 2.3
	 
    CONSTANT Bola_Size : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(8, 10);
	 CONSTANT Bola_Speed : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(2,10);
	 
	 -- Pala 1
	 SIGNAL Pala1_on : STD_LOGIC;
	 SIGNAL Pala1_Desplaza_Y : STD_LOGIC_VECTOR(9 DOWNTO 0);
    SIGNAL Pala1_Y : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(240, 10);
	 
	 CONSTANT Pala1_X : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(Pala1_Init_X, 10);
	 
	 -- Pala 2
	 SIGNAL Pala2_on : STD_LOGIC;
	 SIGNAL Pala2_Desplaza_Y : STD_LOGIC_VECTOR(9 DOWNTO 0);
	 SIGNAL Pala2_Y : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(240, 10);
	 
	 CONSTANT Pala2_X : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(Pala2_Init_X, 10);

	 -- Palas en general
    CONSTANT Pala_Size_Y : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(60, 10);
	 CONSTANT Pala_Size_X : STD_LOGIC_VECTOR(9 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(8, 10);
 
BEGIN
	---------------------- Señales de salida ----------------------
    Red   <= Bola_on or Pala1_on or Pala2_on;
    Green <= Bola_on or Pala1_on or Pala2_on;
    Blue  <= Bola_on or Pala1_on or Pala2_on;

	---------------------- Procesos ----------------------
	-- Bola:
    Dibujar_Bola : PROCESS (Bola_Y, Bola_X, pixel_X, pixel_Y) -- 2.3
    BEGIN
        -- Chequear coordenadas X e Y para identificar el area de la bola
        -- Poner Bola_on a '1' para visualizar la bola
        IF (Bola_X <= pixel_X + Size) AND
            (Bola_X + Size >= pixel_X) AND
            (Bola_Y <= pixel_Y + Size) AND
            (Bola_Y + Size >= pixel_Y) THEN
            Bola_on <= '1';
        ELSE
            Bola_on <= '0';
        END IF;
    END PROCESS Dibujar_Bola;

    Mover_Bola : PROCESS (vs) -- TODO: Añadir rebote
    BEGIN
        -- Actualizar la posicion de la bola en cada refresco de pantalla
        IF vs'event AND vs = '1' THEN
            -- Detectar los bordes superior e inferior de la pantalla
            IF Bola_Y >= CONV_STD_LOGIC_VECTOR(479, 10) - Size THEN
                Desplaza_Bola_Y <= CONV_STD_LOGIC_VECTOR(-2, 10);
            ELSIF Bola_Y <= Size THEN
                Desplaza_Bola_Y <= CONV_STD_LOGIC_VECTOR(2, 10);
            END IF;
				
				-- Detectar los bordes izquierda y derecha de la pantalla
            IF Bola_X >= CONV_STD_LOGIC_VECTOR(639, 10) - Size THEN
                Desplaza_Bola_X <= CONV_STD_LOGIC_VECTOR(-2, 10);
            ELSIF Bola_X <= Size THEN
                Desplaza_Bola_X <= CONV_STD_LOGIC_VECTOR(2, 10);
            END IF;

            -- Calcular la siguiente posicion de la bola
            Bola_Y <= Bola_Y + Desplaza_Bola_Y;
				Bola_X <= Bola_X + Desplaza_Bola_X;
        END IF;
    END PROCESS Mover_Bola;
	 
	 -- Palas:
	 Dibujar_Palas : PROCESS (Pala1_Y, Pala2_Y, pixel_X, pixel_Y) -- 2.3
    BEGIN
			-- Poner Pala1_on a '1' para visualizar la pala1
			-- Chequear coordenadas X e Y para identificar el area de la pala
        IF (Pala1_X <= pixel_X + Pala_Size_X) AND (Pala1_X + Pala_Size_X >= pixel_X) AND
           (Pala1_Y <= pixel_Y + Pala_Size_Y) AND (Pala1_Y + Pala_Size_Y >= pixel_Y) THEN
            Pala1_on <= '1';
        ELSE
            Pala1_on <= '0';
        END IF;
  
		  -- Poner Pala2_on a '1' para visualizar la pala2
		  -- Chequear coordenadas X e Y para identificar el area de la pala
        IF (Pala2_X <= pixel_X + Pala_Size_X) AND (Pala2_X + Pala_Size_X >= pixel_X) AND
           (Pala2_Y <= pixel_Y + Pala_Size_Y) AND (Pala2_Y + Pala_Size_Y >= pixel_Y) THEN
            Pala2_on <= '1';
        ELSE
            Pala2_on <= '0';
        END IF;
    END PROCESS Dibujar_Palas;
	 
    Mover_Palas : PROCESS (vs)
    BEGIN
        -- Actualizar la posicion de la pala en cada refresco de pantalla
        IF vs'event AND vs = '1' THEN
            -- Detectar los bordes superior e inferior de la pantalla
				IF BT1_UP = '0' and BT1_DOWN = '0' then
					 Pala1_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(0, 10);
				ELSIF BT1_UP = '0' and Pala1_Y > Pala_Size_Y then
                Pala1_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(-2, 10);
				ELSIF BT1_DOWN = '0' and Pala1_Y < CONV_STD_LOGIC_VECTOR(479, 10) - Pala_Size_Y then
                Pala1_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(2, 10);
				ELSE
					 Pala1_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(0, 10);
            END IF;
				
				-- Detectar los bordes superior e inferior de la pantalla
				IF BT2_UP = '0' and BT2_DOWN = '0' then
					 Pala1_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(0, 10);
				ELSIF BT2_UP = '0' and Pala2_Y > Pala_Size_Y then
                Pala2_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(-2, 10);
				ELSIF BT2_DOWN = '0' and Pala2_Y < CONV_STD_LOGIC_VECTOR(479, 10) - Pala_Size_Y then
                Pala2_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(2, 10);
				ELSE
					 Pala2_Desplaza_Y <= CONV_STD_LOGIC_VECTOR(0, 10);
            END IF;

            -- Calcular la siguiente posicion de la pala
				Pala1_Y <= Pala1_Y + Pala1_Desplaza_Y;
				Pala2_Y <= Pala2_Y + Pala2_Desplaza_Y;
        END IF;
    END PROCESS Mover_Palas;

END funcional;